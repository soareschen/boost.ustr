<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Unicode String Adapter</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Ustr 0.1">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Ustr 0.1">
<link rel="prev" href="motivation.html" title="Motivation">
<link rel="next" href="unicode_string_adapter_builder.html" title="Unicode String Adapter Builder">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="motivation.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="unicode_string_adapter_builder.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="ustr.unicode_string_adapter"></a><a class="link" href="unicode_string_adapter.html" title="Unicode String Adapter">Unicode String Adapter</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="unicode_string_adapter.html#ustr.unicode_string_adapter.helper_types">Helper Types</a></span></dt>
<dt><span class="section"><a href="unicode_string_adapter.html#ustr.unicode_string_adapter.template">Template Instantiation</a></span></dt>
<dt><span class="section"><a href="unicode_string_adapter.html#ustr.unicode_string_adapter.source_string">Unicode String
      within Source Code</a></span></dt>
<dt><span class="section"><a href="unicode_string_adapter.html#ustr.unicode_string_adapter.api">Unicode String Adapter
      in Library APIs</a></span></dt>
<dt><span class="section"><a href="unicode_string_adapter.html#ustr.unicode_string_adapter.raw_string">Obtaining and
      Constructing From Raw String</a></span></dt>
<dt><span class="section"><a href="unicode_string_adapter.html#ustr.unicode_string_adapter.building_strings">Building
      Unicode Strings</a></span></dt>
<dt><span class="section"><a href="unicode_string_adapter.html#ustr.unicode_string_adapter.concat">String Concatenation</a></span></dt>
<dt><span class="section"><a href="unicode_string_adapter.html#ustr.unicode_string_adapter.iterator">Iterating Through
      Code Points</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="ustr.unicode_string_adapter.helper_types"></a><a class="link" href="unicode_string_adapter.html#ustr.unicode_string_adapter.helper_types" title="Helper Types">Helper Types</a>
</h3></div></div></div>
<p>
        Prior to C++11, there was no standard way of defining UTF-16 and UTF-32 code
        unit types in C++. While <code class="computeroutput"><span class="keyword">wchar_t</span></code>
        was first intended to represent Unicode code unit type, it's exact size is
        not the same among all platforms. For instance, in Visual C++ <code class="computeroutput"><span class="keyword">wchar_t</span></code> is 16-bit in size to represent UTF-16
        code unit, but in GCC <code class="computeroutput"><span class="keyword">wchar_t</span></code>
        is 32-bit in size to represent UTF-32 code unit. The difference make it extremely
        hard to write portable code that uses <code class="computeroutput"><span class="keyword">wchar_t</span></code>
        in Unicode strings.
      </p>
<p>
        With strong demand of standard character types with 16-bit and 32-bit width,
        C++11 introduces <code class="computeroutput"><span class="identifier">char16_t</span></code>
        and <code class="computeroutput"><span class="identifier">char32_t</span></code> as standard
        Unicode code unit types. However as most projects still not yet migrated
        to C++11, Boost.Ustr provides some helper code unit types to represent these
        character types in C++03.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ustr</span><span class="special">::</span><span class="identifier">utf16_codeunit_type</span></code> is used as 16-bit code
        unit type, and is simply typedef to <code class="computeroutput"><span class="identifier">char16_t</span></code>
        if C++11 is enabled. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ustr</span><span class="special">::</span><span class="identifier">codepoint_type</span></code>
        is used as both 32-bit code unit type and code point type, and is simply
        typedef to <code class="computeroutput"><span class="identifier">char32_t</span></code> if C++11
        is enabled. Although the name of the types are slightly long, they are chosen
        mainly to avoid confusion with similar names that are already taken by other
        Unicode projects for potentially different purposes.
      </p>
<p>
        For simplicity and easier understanding in this documentation, we will use
        <code class="computeroutput"><span class="identifier">char16_t</span></code> and <code class="computeroutput"><span class="identifier">char32_t</span></code> in the examples to represent UTF-16
        and UTF-32 code unit types and assume C++11 support. To make sure that the
        code is portable across older compilers, readers are advised to replace the
        types with <code class="computeroutput"><span class="identifier">utf16_codeunit_type</span></code>
        and <code class="computeroutput"><span class="identifier">codepoint_type</span></code> and everything
        else should continue to work properly.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="ustr.unicode_string_adapter.template"></a><a class="link" href="unicode_string_adapter.html#ustr.unicode_string_adapter.template" title="Template Instantiation">Template Instantiation</a>
</h3></div></div></div>
<p>
        Before using Boost.Ustr, developer first need to choose a specific string
        type to make a template instantiation of <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>.
        Some common choices of string types are <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span></code>
        and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>. The string types can contain characters
        of either 8-bit, 16-bit, or 32-bit in size and the appropriate UTF encoding
        will be chosen through the default <code class="computeroutput"><span class="identifier">EncodingTraits</span></code>
        template parameter. Below are some examples of template instance for <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">using</span> <span class="special">::</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ustr</span><span class="special">::</span><span class="identifier">unicode_string_adapter</span><span class="special">;</span>

<span class="comment">// UTF-16 encoding string with std::basic_string as raw container
</span><span class="keyword">class</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">char16_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> 

<span class="comment">// UTF-8 encoding string with std::vector as raw container
</span><span class="keyword">class</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="special">&gt;</span> 

<span class="comment">// UTF-32 encoding string with std::list as raw container
</span><span class="keyword">class</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">char32_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> 
</pre>
<p>
      </p>
<p>
        For ease of use, Boost.Ustr provides three typedefs for string adapters that
        use <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span></code> for UTF-8/16/32 encodings
        respectively:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span>   <span class="identifier">u8_string</span><span class="special">;</span>

<span class="keyword">typedef</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> 
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">utf16_codeunit_type</span><span class="special">&gt;</span> <span class="special">&gt;</span>    <span class="identifier">u16_string</span><span class="special">;</span>

<span class="keyword">typedef</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">codepoint_type</span><span class="special">&gt;</span> <span class="special">&gt;</span>         <span class="identifier">u32_string</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        There are also two optional template parameters that developer can provide
        to change the internal behavior of <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>.
        The <code class="computeroutput"><span class="identifier">StringTraits</span></code> template
        parameter should be supplied if the raw string type do not support STL algorithms
        or has different ways to perform common string operations such as string
        concatenation. The <code class="computeroutput"><span class="identifier">EncodingTraits</span></code>
        template parameter should be supplied if the raw string content is stored
        in encodings other than UTF-8, UTF-16, or UTF-32. For example, an adapter
        that uses STL's rope as the raw string class and Shift-JIS as the internal
        encoding may be written as:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="comment">// String adapter with custom raw string and custom encoding
</span><span class="keyword">class</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span>
    <span class="identifier">stl</span><span class="special">::</span><span class="identifier">rope</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;,</span>

    <span class="comment">// custom string traits that would use rope's fast concatenation API.
</span>    <span class="identifier">rope_string_traits</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;,</span> 

    <span class="comment">// custom non-Unicode encoding that "pretends" to be Unicode encoding
</span>    <span class="identifier">shift_jis_encoding_traits</span><span class="special">&lt;</span> <span class="identifier">rope_string_traits</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="special">&gt;;</span>
</pre>
<p>
      </p>
<p>
        More details on how to construct new string traits and encoding traits will
        be explained in later section.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="ustr.unicode_string_adapter.source_string"></a><a class="link" href="unicode_string_adapter.html#ustr.unicode_string_adapter.source_string" title="Unicode String within Source Code">Unicode String
      within Source Code</a>
</h3></div></div></div>
<p>
        It is a challenging task to do something as simple as constructing static
        Unicode strings within source code, all thanks to Visual C++ which does not
        treat <code class="computeroutput"><span class="keyword">char</span></code> literals as UTF-8
        encoded, even when the source code encoding is in UTF-8. This problem has
        been troubling library developers all the time because the encoding of static
        strings can only be determined during compilation time.
      </p>
<p>
        Even Boost.Ustr requires some preprocessor hacks to make it possible to safely
        construct static Unicode strings within source code. To do so a call to the
        macro <code class="computeroutput"><span class="identifier">USTR</span><span class="special">()</span></code>
        on the static string is needed to make sure that the code is portable across
        different compilers. Below is an example of constructing static Unicode string
        adapters:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">static</span> <span class="keyword">const</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">my_string</span> <span class="special">=</span> <span class="identifier">USTR</span><span class="special">(</span><span class="string">"&#19990;&#30028;&#20320;&#22909;"</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        The <code class="computeroutput"><span class="identifier">USTR</span><span class="special">()</span></code>
        macro is used to enclose the string literal to make sure that the compiler
        stores the string in a supported encoding. It is fine even if the intended
        encoding of the string adapter is not supported by the compiler, because
        <code class="computeroutput"><span class="identifier">USTR</span><span class="special">()</span></code>
        will expand the string literal into a compiler-supported <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        template instance and then automatically convert the encoding during run
        time. For instance, the above code will be expanded into something like
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="comment">// After expansion of USTR() macro
</span><span class="keyword">static</span> <span class="keyword">const</span> <span class="identifier">unicode_string_adapater</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span>
<span class="identifier">my_string</span> <span class="special">=</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="keyword">wchar_t</span><span class="special">&gt;</span> <span class="special">&gt;(</span> <span class="identifier">L</span><span class="string">"&#19990;&#30028;&#20320;&#22909;"</span> <span class="special">);</span>
</pre>
<p>
      </p>
<p>
        Because it is (almost) impossible to construct UTF-8 string literals in Visual
        C++ prior to C++11, <code class="computeroutput"><span class="identifier">USTR</span><span class="special">()</span></code> would use <code class="computeroutput"><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="keyword">wchar_t</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>
        to hold the static string that is constructed using the L"" prefix,
        which tells the compiler to store the string literal in wchar_t array using
        UTF-16 encoding.
      </p>
<p>
        However because the variable <code class="computeroutput"><span class="identifier">my_string</span></code>
        has the type of string adapter for std::string, which uses UTF-8 encoding,
        the automatic conversion will kick in during run time to convert the UTF-16
        string adapter into UTF-8 string adapter.
      </p>
<p>
        The <code class="computeroutput"><span class="identifier">USTR</span><span class="special">()</span></code>
        macro also comes in handy when constructing string adapters with raw string
        types that cannot be constructed from C-style character array. For example,
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> can be constructed from <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span></code> but <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span></code>
        can't. Without the <code class="computeroutput"><span class="identifier">USTR</span><span class="special">()</span></code>
        macro, the construction of <code class="computeroutput"><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span>
        <span class="special">&gt;</span></code> from <code class="computeroutput"><span class="keyword">const</span>
        <span class="keyword">char</span><span class="special">*</span></code>
        string literals would fail.
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="comment">// Won't compile: No appropriate constructor from const char*
</span><span class="comment">// unicode_string_adapter&lt; std::vector&lt;char&gt; &gt; my_string = "Hello World!";
</span>
<span class="comment">// Will compile and also supports Unicode string literals across platforms
</span><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">my_string</span> <span class="special">=</span> <span class="identifier">USTR</span><span class="special">(</span><span class="string">"Hello World!"</span><span class="special">);</span>

<span class="comment">// The complete expansion together with the std::string default constructor
</span><span class="comment">// (Assuming it is on GCC-C++11 which supports UTF-8 string literal.
</span><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="identifier">my_string</span> <span class="special">=</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="identifier">u8</span><span class="string">"Hello World!"</span><span class="special">)</span> <span class="special">);</span>
</pre>
<p>
      </p>
<p>
        Behind the scene, <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        actually does not have any constructor that accepts C-style character array.
        However because <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span></code> has default constructor that
        accepts the raw character array, the compiler will match the implicit constructor
        of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span></code> and then only match the implicitly
        constructed <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span></code> with the explicit constructor
        of <code class="computeroutput"><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">unicode_string_adapter</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">CharT</span><span class="special">&gt;&amp;</span> <span class="identifier">str</span><span class="special">)</span></code>
      </p>
<p>
        <code class="computeroutput"><span class="identifier">USTR</span><span class="special">()</span></code>
        will use the new Unicode string literal prefix u"" if C++11 is
        supported. And whenever possible, <code class="computeroutput"><span class="identifier">USTR</span><span class="special">()</span></code> will try to instruct the compiler to store
        the string literal in UTF-8 encoding.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="ustr.unicode_string_adapter.api"></a><a class="link" href="unicode_string_adapter.html#ustr.unicode_string_adapter.api" title="Unicode String Adapter in Library APIs">Unicode String Adapter
      in Library APIs</a>
</h3></div></div></div>
<p>
        Boost.Ustr solves a painful problem for library developers by making it possible
        for library APIs to accept Unicode strings stored in any character container
        with any encoding. Prior to this, library writers have to choose between
        accepting <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span></code> of either <code class="computeroutput"><span class="keyword">char</span></code>
        or <code class="computeroutput"><span class="keyword">wchar_t</span></code> in their library
        API, unless they are willing to duplicate the effort to accept both string
        types.
      </p>
<p>
        With Boost.Ustr, there are two ways of accepting Unicode strings in library
        APIs: one is to use template that accepts generic <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        and another is to accept specific template instance of <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>.
        First, the generic API could be constructed similar to as follow:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">StringT</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">StringTraits</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">EncodingTraits</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">my_library_function</span><span class="special">(</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span><span class="identifier">StringT</span><span class="special">,</span> <span class="identifier">StringTraits</span><span class="special">,</span> <span class="identifier">EncodingTraits</span><span class="special">&gt;</span> <span class="identifier">str</span> <span class="special">);</span>
</pre>
<p>
      </p>
<p>
        The benefit of this generic approach is that the library will always use
        the same <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        template instance as the caller, thereby saving potential cost of converting
        between different encodings or strings. However the down side is that the
        code become slightly less readable, and this approach cannot be used in virtual
        functions and also functions that return but don't accept Unicode strings.
        Under these circumstances the library writer then has to choose a specific
        template instance of <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="comment">// Alternative version of the example above
</span><span class="keyword">void</span> <span class="identifier">my_alt_library_function</span><span class="special">(</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">str</span> <span class="special">);</span>

<span class="keyword">class</span> <span class="identifier">my_library_class</span> <span class="special">{</span>
    <span class="special">...</span>
    <span class="comment">// Virtual functions cannot be templated
</span>    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">my_member_library_function</span><span class="special">(</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">str</span> <span class="special">);</span>
    <span class="special">...</span>
<span class="special">};</span>

<span class="comment">// Library function that return but do not accept Unicode strings
</span><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">my_returning_library_function</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">arg</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        Even though the library APIs accept or return specific template instance
        of <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>,
        the automatic conversion facility makes it possible for callers to pass in
        or receive any template instance of <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        through the library APIs without additional effort. For example, the following
        calls to the above example library APIs are valid:
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="comment">// my_string is in UTF-16 encoding using std::vector as raw string type
</span><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">char16_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">my_string</span> <span class="special">=</span> <span class="identifier">USTR</span><span class="special">(</span><span class="string">"&#19990;&#30028;&#20320;&#22909;"</span><span class="special">);</span>

<span class="comment">// Call generic function that accepts all unicode_string_adapter: OK
</span><span class="identifier">my_library_function</span><span class="special">(</span><span class="identifier">my_string</span><span class="special">);</span>

<span class="comment">// Call function that accepts different unicode_string_adapter: OK
</span><span class="identifier">my_alt_library_function</span><span class="special">(</span><span class="identifier">my_string</span><span class="special">);</span>

<span class="identifier">my_library_class</span> <span class="special">*</span><span class="identifier">my_object</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">my_library_class</span><span class="special">();</span>
<span class="identifier">my_object</span><span class="special">-&gt;</span><span class="identifier">my_member_library_function</span><span class="special">(</span><span class="identifier">my_string</span><span class="special">);</span>

<span class="comment">// Function returns UTF-8 string but the variable expects UTF-32 string: OK
</span><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">char32_t</span><span class="special">&gt;</span> <span class="special">&gt;</span> 
<span class="identifier">my_other_string</span> <span class="special">=</span> <span class="identifier">my_returning_library_function</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="ustr.unicode_string_adapter.raw_string"></a><a class="link" href="unicode_string_adapter.html#ustr.unicode_string_adapter.raw_string" title="Obtaining and Constructing From Raw String">Obtaining and
      Constructing From Raw String</a>
</h3></div></div></div>
<p>
        Because <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        only wraps around a raw string type to provide additional functionality,
        it is easy to convert it to and from a raw string instance. A const reference
        to the internal raw string is easily obtainable through the operator *()
        function. This is especially useful when the string adapter user wants to
        pass the string into traditional APIs that accept the raw string. However
        because <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        stores the raw string object on the heap, developers should note the extra
        cost of copying the raw string into a local variable and should try to minimize
        such operation. The raw string specific functions can also be accessed through
        operator -&gt;(), although only const methods are allowed.
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="comment">// Legacy library API that accepts only raw std::string but correctly 
</span><span class="comment">// expects UTF-8 encoding
</span><span class="keyword">void</span> <span class="identifier">my_legacy_function</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">str</span><span class="special">);</span>

<span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">my_string</span> <span class="special">=</span> <span class="identifier">USTR</span><span class="special">(</span><span class="string">"&#19990;&#30028;&#20320;&#22909;"</span><span class="special">);</span>

<span class="comment">// A local copy operation is performed to copy the string content
</span><span class="comment">// from the heap to the stack. This might get expensive if done too much.
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">my_raw_string</span> <span class="special">=</span> <span class="special">*</span><span class="identifier">my_string</span><span class="special">;</span>

<span class="comment">// Because the function accepts const reference, no extra copying is needed
</span><span class="identifier">my_legacy_function</span><span class="special">(*</span><span class="identifier">my_string</span><span class="special">);</span>

<span class="comment">// Calls std::string::begin(). It returns the raw code unit iterator
</span><span class="comment">// instead of the string adapter's code point iterator
</span><span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">my_string</span><span class="special">-&gt;</span><span class="identifier">begin</span><span class="special">();</span>
</pre>
<p>
      </p>
<p>
        While obtaining raw string from <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        is quite simple, constructing string adapter from raw string is slightly
        more complicated. Firstly the constructer from raw string type is made explicit
        to prevent accidental conversion. This is required because not all raw strings
        store their content in the expected Unicode encoding. The explicit construction
        force the developer to make aware of the type conversion so that the developer
        can personally make sure that the raw string is in the expected encoding.
      </p>
<p>
        Furthermore, because <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        stores the raw string on the heap, a copy operation would be necessary when
        default constructing from reference of strings. This is also unavoidable
        as the original raw string might be mutable while <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        is immutable, therefore making the potentially mutable string content unshareable.
        If performance is in concern developer may use other explicit constructors
        that accept raw pointer or shared pointer of the raw string.
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="comment">// It is however not portable to construct Unicode string literals 
</span><span class="comment">// in this way, so we use English here.
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">my_raw_string</span> <span class="special">=</span> <span class="string">"Hello World!"</span><span class="special">;</span>

<span class="comment">// Explicit constructor is called
</span><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">my_unicode_string</span><span class="special">(</span><span class="identifier">my_raw_string</span><span class="special">);</span>

<span class="keyword">void</span> <span class="identifier">my_library_function</span><span class="special">(</span><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">arg</span><span class="special">);</span>

<span class="comment">// When passed to functions that accept unicode_string_adapter,
</span><span class="comment">// the constructor must be explicitly called
</span><span class="identifier">my_library_function</span><span class="special">(</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">my_raw_string</span><span class="special">)</span> <span class="special">);</span>

<span class="comment">// This won't compile because there's no implicit conversion
</span><span class="comment">// my_library_function(my_raw_string);
</span>
<span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">*</span><span class="identifier">my_string_ptr</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="string">"Hello World!"</span><span class="special">);</span>

<span class="comment">// No extra copying needed
</span><span class="comment">// However be careful to not use the raw pointer anymore because
</span><span class="comment">// the ownership has been transfered!
</span><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">my_unicode_string2</span><span class="special">(</span><span class="identifier">my_string_ptr</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="ustr.unicode_string_adapter.building_strings"></a><a class="link" href="unicode_string_adapter.html#ustr.unicode_string_adapter.building_strings" title="Building Unicode Strings">Building
      Unicode Strings</a>
</h3></div></div></div>
<p>
        Other than building from raw strings, <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        also provides two static helper functions to construct from generic code
        point iterators and code unit iterators. This is useful for conversion to
        <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code> from
        any source of Unicode strings.
      </p>
<a name="ustr.unicode_string_adapter.building_strings.from_code_point"></a><h4>
<a name="id641400"></a>
        <a class="link" href="unicode_string_adapter.html#ustr.unicode_string_adapter.building_strings.from_code_point">From
        Code Point</a>
      </h4>
<p>
        The static <code class="computeroutput"><span class="identifier">unicode_string_adapter</span><span class="special">::</span><span class="identifier">from_codepoint</span><span class="special">()</span></code> function takes a begin and end code point
        iterator and constructs a new <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        that stores the given code points under the appropriate Unicode encoding.
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span>     <span class="identifier">u8_string</span><span class="special">;</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">codepoint_type</span><span class="special">&gt;</span> <span class="identifier">codepoints</span> <span class="special">=</span> <span class="identifier">get_codepoints_from_data_source</span><span class="special">();</span>

<span class="identifier">u8_string</span> <span class="identifier">my_encoded_string</span> <span class="special">=</span> <span class="identifier">u8_string</span><span class="special">::</span><span class="identifier">from_codepoints</span><span class="special">(</span><span class="identifier">codepoints</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">codepoints</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
</pre>
<p>
      </p>
<a name="ustr.unicode_string_adapter.building_strings.from_code_unit"></a><h4>
<a name="id641611"></a>
        <a class="link" href="unicode_string_adapter.html#ustr.unicode_string_adapter.building_strings.from_code_unit">From
        Code Unit</a>
      </h4>
<p>
        Sometimes it is desirable to convert encoded form of some other Unicode string
        types into <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        that wraps a different raw string type. The <code class="computeroutput"><span class="identifier">unicode_string_adapter</span><span class="special">::</span><span class="identifier">from_codeunits</span><span class="special">()</span></code> helper function allows direct conversion
        in encoded form without having to decode the source string and re-encode
        to the string adapter again. However it is assumed that the caller of this
        helper function have the source string encoded in the same encoding as the
        <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>, otherwise
        the resulting string would produce malformed content.
      </p>
<p>
        Below is an example of a terminal application that expects UTF-16 encoded
        string from stdin.
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="identifier">char16_t</span><span class="special">&gt;</span> <span class="special">&gt;</span>   <span class="identifier">u16_string</span><span class="special">;</span>

<span class="comment">// Wraps std::cin inside input stream iterator so that we can
</span><span class="comment">// iterator over the code units.
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">istream_iterator</span><span class="special">&lt;</span><span class="identifier">char16_t</span><span class="special">&gt;</span> <span class="identifier">iit</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">cin</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">istream_iterator</span><span class="special">&lt;</span><span class="identifier">char16_t</span><span class="special">&gt;</span> <span class="identifier">eos</span><span class="special">;</span>

<span class="comment">// Directly copy the UTF-16 code units into the Unicode string adapter
</span><span class="comment">// without having to go through manual decoding. Any encoding error
</span><span class="comment">// will be handled by the string adapter
</span><span class="identifier">u16_string</span> <span class="identifier">my_string</span> <span class="special">=</span> <span class="identifier">u16_string</span><span class="special">::</span><span class="identifier">from_codeunits</span><span class="special">(</span><span class="identifier">iit</span><span class="special">,</span> <span class="identifier">eos</span><span class="special">);</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="ustr.unicode_string_adapter.concat"></a><a class="link" href="unicode_string_adapter.html#ustr.unicode_string_adapter.concat" title="String Concatenation">String Concatenation</a>
</h3></div></div></div>
<p>
        Concatenation of two <code class="computeroutput"><span class="identifier">unicode_string_adapater</span></code>
        is straightforward through <code class="computeroutput"><span class="keyword">operator</span>
        <span class="special">+()</span></code>. It is possible to concatenate
        strings of different <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        template instances, in which case the type of resulting string would follow
        the type of the first operand.
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">first_string</span> <span class="special">=</span> <span class="identifier">USTR</span><span class="special">(</span><span class="string">"&#19990;&#30028;"</span><span class="special">);</span>
<span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">char16_t</span> <span class="special">&gt;</span> <span class="identifier">second_string</span> <span class="special">=</span> <span class="identifier">USTR</span><span class="special">(</span><span class="string">"&#20320;&#22909;"</span><span class="special">);</span>

<span class="comment">// The return type is the same type as the first operand
</span><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">new_string</span> <span class="special">=</span> <span class="identifier">first_string</span> <span class="special">+</span> <span class="identifier">second_string</span><span class="special">;</span>

<span class="comment">// However with the help of automatic conversion, it is possible to specify a different
</span><span class="comment">// template instance from the two operands. A run time conversion will take place in this case.
</span><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span><span class="keyword">wchar_t</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="identifier">another_string</span> <span class="special">=</span> <span class="identifier">first_string</span> <span class="special">+</span> <span class="identifier">second_string</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        Notice however that because <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code>
        is immutable, a new copy of string is always be created during concatenation.
        There is also no <code class="computeroutput"><span class="keyword">operator</span> <span class="special">+=()</span></code>
        available, so append operation is not allowed.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="ustr.unicode_string_adapter.iterator"></a><a class="link" href="unicode_string_adapter.html#ustr.unicode_string_adapter.iterator" title="Iterating Through Code Points">Iterating Through
      Code Points</a>
</h3></div></div></div>
<p>
        <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code> provides
        uniform access to code points stored in strings encoded in any Unicode encoding.
        The access is straight forward by simply calling <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code> to retrieve the code point iterators. The
        <code class="computeroutput"><span class="identifier">value_type</span></code> for the iterator
        is <code class="computeroutput"><span class="keyword">const</span> <span class="identifier">codepoint_type</span></code>
        when derefenced via <code class="computeroutput"><span class="keyword">operator</span> <span class="special">*()</span></code>. The code point iterator will perform
        the decoding operating behind the scene using the appropriate decoding engine,
        so the user do not need to know which encoding the Unicode string is encoded
        in.
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">my_string</span> <span class="special">=</span> <span class="identifier">USTR</span><span class="special">(</span><span class="string">"&#19990;&#30028;&#20320;&#22909;"</span><span class="special">);</span>

<span class="keyword">typename</span> <span class="identifier">unicode_string_adapter</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;::</span><span class="identifier">iterator</span>
<span class="identifier">it</span> <span class="special">=</span> <span class="identifier">my_string</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>

<span class="keyword">while</span><span class="special">(</span><span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">my_string</span><span class="special">.</span><span class="identifier">end</span><span class="special">())</span> <span class="special">{</span>
    <span class="comment">// print the decoded code point value onto the terminal
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">codepoint_type</span><span class="special">&gt;</span> <span class="identifier">decoded</span><span class="special">;</span>

<span class="comment">// Code point iterators work with STL algorithms
</span><span class="comment">// In this case we are copying the decoded code points into 
</span><span class="comment">// a vector of code points.
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">copy</span><span class="special">(</span><span class="identifier">my_string</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">my_string</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">back_inserter</span><span class="special">(</span><span class="identifier">decoded</span><span class="special">));</span>
</pre>
<p>
      </p>
<p>
        <code class="computeroutput"><span class="identifier">unicode_string_adapter</span></code> does
        not provide direct way to access a string's code units in encoded form. This
        is because the whole purpose of this class is to hide the abstraction so
        that developer don't have to deal with strings of different encodings. Although
        code unit iterators can typically be obtained by calling the raw string's
        <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>
        method via <code class="computeroutput"><span class="keyword">operator</span> <span class="special">-&gt;()</span></code>,
        it is strongly not recommended as doing so would make the code much less
        portable.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2011 Soares Chen Ruo Fei<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="motivation.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="unicode_string_adapter_builder.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
