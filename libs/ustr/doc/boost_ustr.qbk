[/==============================================================================
    Copyright (C) 2003-2010 Thorsten Ottosen, Neil Groves

    Use, modification and distribution is subject to the Boost Software
    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt
==============================================================================/]
[library Ustr
    [quickbook 1.5]
    [version 0.1]
    [authors [Soares, Chen Ruo Fei]]
    [copyright 2011 Soares Chen Ruo Fei]
    [purpose Boost Unicode String Adapter Library]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[section:introduction Introduction]
Boost.Ustr provides a Unicode string adapter class that wraps traditional string containers 
such as `std::string` to attach Unicode encoding semantics to it.

The main class that is used in Boost.Ustr is `unicode_string_adapter` with the following template signature:

``
    template <typename StringT, typename StringTraits, typename EncodingTraits>
    class unicode_string_adapter;
``

where

* `StringT` is the raw string type that will be wrapped.
* `StringTraits` is the facade to the manipulation of the raw string.
* `EncodingTraits` implements the encoding/decoding operations of the raw string content.

Boost.Ustr has default `StringTraits` and `EncodingTraits` for most of the containers. 
So it is usually sufficient to supply just the raw string type to the template.
for example, a Unicode string adapter with std::string as the raw string type would be instantiated as

``
    class unicode_string_adapter< std::string >
``

[section:benefits Benefits over Raw Strings]

There are several benefits to wrap raw string types within `unicode_string_adapter` instead of 
using the raw strings directly.

[h3 Code Point Level Access]
`unicode_string_adapter` encapsulates the encoding/decoding operations of code units of different 
Unicode encodings. Instead it returns code point iterators in the `begin()` and `end()` methods so that
developers do not have to concern on which encoding the raw string is actually using.

[h3 Automatic Conversion Between Template Instances]
A template instance of `unicode_string_adapter` can be automatically converted to another template instance. 
This is useful for cases such as when the developer uses strings with encoding different from the 
encoding expected from library APIs.

[h3 Efficient Copy with Immutable String]
`unicode_string_adapter` is an immutable string class. Internally the raw string is stored on the heap 
and uses smart pointer to share the raw string among different objects. This gives more efficient copy operation
that is faster than many raw string types that perform deep copying, including std::string in C++11.

[endsect]

[endsect]

[section:motivation Motivation]

The main reason that Boost.Ustr is developed is because current raw string types such as std::string requires
developers to make assumption on the encoding of the string content, such as UTF-8 for std::string. This 
creates inconsistency when a string passed to library APIs has different encoding from the library expects. 
The problem mainly arise because there are a small minority of developers who use different encoding for the
same string type.

Various proposals have been made to solve this issue, but most proposals are mainly focused on creating new 
Unicode string classes that enforce encoding correctness. However the Boost community were reluctant on 
introducing yet another string class into the C++ ecosystem. This is because std::basic_string has already 
been widely adopted by the C++ community and the switching cost is belived to be too high for the new string 
class to be adopted widely. Furthermore, most of the discussions were focusing mainly on the feasibility of 
creating another string class rather than bringing encoding awareness into strings.

Because string and encoding are two separate issues, it is preferable that string classes should be act as
raw character containers and leave the encoding issues to a higher layer of abstraction. Using this approach,
we create `unicode_string_adapter` as a generic adapter for arbitrary string classes to provide encoding 
awareness through additional layer. This is better than creating new Unicode string classes because developers 
have the freedom of continue using their own favorite string classes in addition to benefiting from the encoding 
awareness.

[endsect]


[section:unicode_string_adapter Unicode String Adapter]

[section:helper_types Helper Types]
Prior to C++11, there was no standard way of defining UTF-16 and UTF-32 code unit types in C++. While `wchar_t` 
was first intended to represent Unicode code unit type, it's exact size is not the same among all platforms. 
For instance, in Visual C++ `wchar_t` is 16-bit in size to represent UTF-16 code unit, but in GCC `wchar_t` is 
32-bit in size to represent UTF-32 code unit. The difference make it extremely hard to write portable code that
uses `wchar_t` in Unicode strings.

With strong demand of standard character types with 16-bit and 32-bit width, C++11 introduces `char16_t` and 
`char32_t` as standard Unicode code unit types. However as most projects still not yet migrated to C++11, 
Boost.Ustr provides some helper code unit types to represent these character types in C++03.

`boost::ustr::utf16_codeunit_type` is used as 16-bit code unit type, and is simply typedef to `char16_t` if 
C++11 is enabled. `boost::ustr::codepoint_type` is used as both 32-bit code unit type and code point type, and 
is simply typedef to `char32_t` if C++11 is enabled. Although the name of the types are slightly long, they are 
chosen mainly to avoid confusion with similar names that are already taken by other Unicode projects for 
potentially different purposes.

For simplicity and easier understanding in this documentation, we will use `char16_t` and `char32_t` in the 
examples to represent UTF-16 and UTF-32 code unit types and assume C++11 support. To make sure that the code 
is portable across older compilers, readers are advised to replace the types with  `utf16_codeunit_type` 
and `codepoint_type` and everything else should continue to work properly.
[endsect]

[section:template Template Instantiation]
Before using Boost.Ustr, developer first need to choose a specific string type to make a template instantiation of
`unicode_string_adapter`. Some common choices of string types are `std::basic_string` and `std::vector`.
The string types can contain characters of either 8-bit, 16-bit, or 32-bit in size and the appropriate
UTF encoding will be chosen through the default `EncodingTraits` template parameter. Below are some examples
of template instance for `unicode_string_adapter`:

``
    using ::boost::ustr::unicode_string_adapter;

    // UTF-16 encoding string with std::basic_string as raw container
    class unicode_string_adapter< std::basic_string<char16_t> > 

    // UTF-8 encoding string with std::vector as raw container
    class unicode_string_adapter< std::vector<char> > 

    // UTF-32 encoding string with std::list as raw container
    class unicode_string_adapter< std::list<char32_t> > 
``

For ease of use, Boost.Ustr provides three typedefs for string adapters that use `std::basic_string` for
UTF-8/16/32 encodings respectively:

``
    typedef unicode_string_adapter< std::string >   u8_string;

    typedef unicode_string_adapter< 
        std::basic_string<utf16_codeunit_type> >    u16_string;

    typedef unicode_string_adapter<
        std::basic_string<codepoint_type> >         u32_string;
``

There are also two optional template parameters that developer can provide to change the internal behavior of
`unicode_string_adapter`. The `StringTraits` template parameter should be supplied if the raw string type 
do not support STL algorithms or has different ways to perform common string operations such as string concatenation.
The `EncodingTraits` template parameter should be supplied if the raw string content is stored in encodings other
than UTF-8, UTF-16, or UTF-32. For example, an adapter that uses STL's rope as the raw string class and Shift-JIS 
as the internal encoding may be written as:

``
    // String adapter with custom raw string and custom encoding
    class unicode_string_adapter<
        stl::rope<char>,

        // custom string traits that would use rope's fast concatenation API.
        rope_string_traits<char>, 

        // custom non-Unicode encoding that "pretends" to be Unicode encoding
        shift_jis_encoding_traits< rope_string_traits<char> >
    >;
``

More details on how to construct new string traits and encoding traits will be explained in later section.

[endsect]

[section:source_string Unicode String within Source Code]

It is a challenging task to do something as simple as constructing static Unicode strings within source code,
all thanks to Visual C++ which does not treat `char` literals as UTF-8 encoded, even when the source code encoding 
is in UTF-8. This problem has been troubling library developers all the time because the encoding of static strings
can only be determined during compilation time.

Even Boost.Ustr requires some preprocessor hacks to make it possible to safely construct static Unicode strings 
within source code. To do so a call to the macro `USTR()` on the static string is needed to make sure that the code
is portable across different compilers. Below is an example of constructing static Unicode string adapters:

``
    static const unicode_string_adapter< std::string > my_string = USTR("世界你好");
``

The `USTR()` macro is used to enclose the string literal to make sure that the compiler stores the string in a 
supported encoding. It is fine even if the intended encoding of the string adapter is not supported by the compiler,
because `USTR()` will expand the string literal into a compiler-supported `unicode_string_adapter` template instance
and then automatically convert the encoding during run time. For instance, the above code will be expanded into 
something like

``
    // After expansion of USTR() macro
    static const unicode_string_adapater< std::string >
    my_string = unicode_string_adapter< std::basic_string<wchar_t> >( L"世界你好" );
``

Because it is (almost) impossible to construct UTF-8 string literals in Visual C++ prior to C++11, `USTR()` would
use `unicode_string_adapter< std::basic_string<wchar_t> >` to hold the static string that is constructed using 
the L"" prefix, which tells the compiler to store the string literal in wchar_t array using UTF-16 encoding.

However because the variable `my_string` has the type of string adapter for std::string, which uses UTF-8 encoding,
the automatic conversion will kick in during run time to convert the UTF-16 string adapter into
UTF-8 string adapter.

The `USTR()` macro also comes in handy when constructing string adapters with raw string types that cannot be 
constructed from C-style character array. For example, `std::string` can be constructed from `const char*` but 
`std::vector<char>` can't. Without the `USTR()` macro, the construction of 
`unicode_string_adapter< std::vector<char> >` from `const char*` string literals would fail. 

``
    // Won't compile: No appropriate constructor from const char*
    // unicode_string_adapter< std::vector<char> > my_string = "Hello World!";

    // Will compile and also supports Unicode string literals across platforms
    unicode_string_adapter< std::vector<char> > my_string = USTR("Hello World!");

    // The complete expansion together with the std::string default constructor
    // (Assuming it is on GCC-C++11 which supports UTF-8 string literal.
    unicode_string_adapter< std::vector<char> >
    my_string = unicode_string_adapter< std::string >( std::string(u8"Hello World!") );
``

Behind the scene, `unicode_string_adapter` actually does not have any constructor that accepts
C-style character array. However because `std::basic_string` has default constructor that accepts 
the raw character array, the compiler will match the implicit constructor of `std::basic_string` and then
only match the implicitly constructed `std::basic_string` with the explicit constructor of 
`unicode_string_adapter< std::basic_string<CharT> >::unicode_string_adapter(const std::basic_string<CharT>& str)`

`USTR()` will use the new Unicode string literal prefix u"" if C++11 is supported. And whenever possible, 
`USTR()` will try to instruct the compiler to store the string literal in UTF-8 encoding.

[endsect]

[section:api Unicode String Adapter in Library APIs]

Boost.Ustr solves a painful problem for library developers by making it possible for library APIs to accept 
Unicode strings stored in any character container with any encoding. Prior to this, library writers have to 
choose between accepting `std::basic_string` of either `char` or `wchar_t` in their library API, unless they 
are willing to duplicate the effort to accept both string types.

With Boost.Ustr, there are two ways of accepting Unicode strings in library APIs: one is to use template 
that accepts generic `unicode_string_adapter` and another is to accept specific template instance of 
`unicode_string_adapter`. First, the generic API could be constructed similar to as follow:

``
    template< typename StringT, typename StringTraits, typename EncodingTraits>
    void my_library_function( unicode_string_adapter<StringT, StringTraits, EncodingTraits> str );
``

The benefit of this generic approach is that the library will always use the same `unicode_string_adapter` template
instance as the caller, thereby saving potential cost of converting between different encodings or strings.
However the down side is that the code become slightly less readable, and this approach cannot be used
in virtual functions and also functions that return but don't accept Unicode strings. Under these circumstances the 
library writer then has to choose a specific template instance of `unicode_string_adapter`:

``
    // Alternative version of the example above
    void my_alt_library_function( unicode_string_adapter< std::string > str );

    class my_library_class {
        ...
        // Virtual functions cannot be templated
        virtual void my_member_library_function( unicode_string_adapter< std::string > str );
        ...
    };

    // Library function that return but do not accept Unicode strings
    unicode_string_adapter< std::string > my_returning_library_function(int arg);
``

Even though the library APIs accept or return specific template instance of `unicode_string_adapter`, the automatic 
conversion facility makes it possible for callers to pass in or receive any template instance of 
`unicode_string_adapter` through the library APIs without additional effort. For example, the following calls
to the above example library APIs are valid:

``
    // my_string is in UTF-16 encoding using std::vector as raw string type
    unicode_string_adapter< std::vector<char16_t> > my_string = USTR("世界你好");

    // Call generic function that accepts all unicode_string_adapter: OK
    my_library_function(my_string);

    // Call function that accepts different unicode_string_adapter: OK
    my_alt_library_function(my_string);

    my_library_class *my_object = new my_library_class();
    my_object->my_member_library_function(my_string);

    // Function returns UTF-8 string but the variable expects UTF-32 string: OK
    unicode_string_adapter< std::basic_string<char32_t> > 
    my_other_string = my_returning_library_function(0);
``

[endsect]

[section:raw_string Obtaining and Constructing From Raw String]

Because `unicode_string_adapter` only wraps around a raw string type to provide additional functionality, it is
easy to convert it to and from a raw string instance. A const reference to the internal raw string is easily 
obtainable through the operator *() function. This is especially useful when the string adapter user wants to 
pass the string into traditional APIs that accept the raw string. However because `unicode_string_adapter` 
stores the raw string  object on the heap, developers should note the extra cost of copying the raw string 
into a local variable and should try to minimize such operation. The raw string specific functions can also 
be accessed through operator ->(), although only const methods are allowed.

``
    unicode_string_adapter< std::string > my_string = USTR("世界你好");

    // A local copy operation is performed to copy the string content
    // from the heap to the stack. This might get expensive if done too much.
    std::string my_raw_string = *my_string;

    // Legacy library API that accepts only raw std::string but correctly 
    // expects UTF-8 encoding
    void my_legacy_function(const std::string& str);

    // Because the function accepts const reference, no extra copying is needed
    my_legacy_function(*my_string);

    // C library API that accepts only C-style string but correclty expects 
    // UTF-8 encoding
    void my_c_function(const char* str);

    // Pass const char* to C function through std::string::c_str(). This is handy 
    // because we are using std::string's existing method instead of having to  
    // reinvent it on unicode_string_adapter.
    my_c_function(my_string->c_str());
``

While obtaining raw string from `unicode_string_adapter` is quite simple, constructing string adapter 
from raw string is slightly more complicated. Firstly the constructer from raw string type is made explicit 
to prevent accidental conversion. This is required because not all raw strings store their content in the 
expected Unicode encoding. The explicit construction force the developer to make aware of the type conversion 
so that the developer can personally make sure that the raw string is in the expected encoding.

Furthermore, because `unicode_string_adapter` stores the raw string on the heap, a copy operation would be 
necessary when default constructing from reference of strings. This is also unavoidable as the original 
raw string might be mutable while `unicode_string_adapter` is immutable, therefore making the potentially 
mutable string content unshareable. If performance is in concern developer may use other explicit constructors 
that accept raw pointer or shared pointer of the raw string.

``
    // It is however not portable to construct Unicode string literals 
    // in this way, so we use English here.
    std::string my_raw_string = "Hello World!";

    // Explicit constructor is called
    unicode_string_adapter<std::string> my_unicode_string(my_raw_string);

    void my_library_function(unicode_string_adapter<std::string> arg);

    // When passed to functions that accept unicode_string_adapter,
    // the constructor must be explicitly called
    my_library_function( unicode_string_adapter<std::string>(my_raw_string) );

    // This won't compile because there's no implicit conversion
    // my_library_function(my_raw_string);

    const std::string *my_string_ptr = new std::string("Hello World!");

    // No extra copying needed
    // However be careful to not use the raw pointer anymore because
    // the ownership has been transfered!
    unicode_string_adapter<std::string> my_unicode_string2(my_string_ptr);
``

[endsect]

[section:building_strings Building Unicode Strings]
Other than building from raw strings, `unicode_string_adapter` also provides two static helper functions
to construct from generic code point iterators and code unit iterators. This is useful for conversion to 
`unicode_string_adapter` from any source of Unicode strings.

[h3 From Code Point]
The static `unicode_string_adapter::from_codepoint()` function takes a begin and end code point iterator and
constructs a new `unicode_string_adapter` that stores the given code points under the appropriate Unicode encoding.

``
    typedef unicode_string_adapter<std::string>     u8_string;

    std::vector<codepoint_type> codepoints = get_codepoints_from_data_source();

    u8_string my_encoded_string = u8_string::from_codepoints(codepoints.begin(), codepoints.end());
``

[h3 From Code Unit]
Sometimes it is desirable to convert encoded form of some other Unicode string types into `unicode_string_adapter` 
that wraps a different raw string type. The `unicode_string_adapter::from_codeunits()` helper function allows direct 
conversion in encoded form without having to decode the source string and re-encode to the string adapter again. 
However it is assumed that the caller of this helper function have the source string encoded in the same encoding 
as the `unicode_string_adapter`, otherwise the resulting string would produce malformed content.

Below is an example of a terminal application that expects UTF-16 encoded string from stdin.

``
    typedef unicode_string_adapter< std::basic_string<char16_t> >   u16_string;

    // Wraps std::cin inside input stream iterator so that we can
    // iterator over the code units.
    std::istream_iterator<char16_t> iit(std::cin);
    std::istream_iterator<char16_t> eos;

    // Directly copy the UTF-16 code units into the Unicode string adapter
    // without having to go through manual decoding. Any encoding error
    // will be handled by the string adapter
    u16_string my_string = u16_string::from_codeunits(iit, eos);
``

[endsect]

[section:concat String Concatenation]

Concatenation of two `unicode_string_adapater` is straightforward through `operator +()`. It is possible to 
concatenate strings of different `unicode_string_adapter` template instances, in which case the type of 
resulting string would follow the type of the first operand.

``
    unicode_string_adapter< std::string > first_string = USTR("世界");
    unicode_string_adapter< std::vector< char16_t > > second_string = USTR("你好");

    // The return type is the same type as the first operand
    unicode_string_adapter< std::string > new_string = first_string + second_string;

    // However with the help of automatic conversion, it is possible to specify a different
    // template instance from the two operands. A run time conversion will take place in this case.
    unicode_string_adapter< std::basic_string<wchar_t> >
    another_string = first_string + second_string;
``

Notice however that because `unicode_string_adapter` is immutable, a new copy of string is always be created during 
concatenation. There is also no `operator +=()` available, so append operation is not allowed.

[endsect]

[section:iterator Iterating Through Code Points]

`unicode_string_adapter` provides uniform access to code points stored in strings encoded in any Unicode encoding. 
The access is straight forward by simply calling `begin()` and `end()` to retrieve the code point iterators. The 
`value_type` for the iterator is `const codepoint_type` when derefenced via `operator *()`. The code point iterator 
will perform the decoding operation behind the scene using the appropriate decoding engine, so the user do not need 
to know which encoding the Unicode string is encoded in.

``
    unicode_string_adapter< std::string > my_string = USTR("世界你好");

    typename unicode_string_adapter< std::string >::iterator
    it = my_string.begin();

    while(it != my_string.end()) {
        // print the decoded code point value onto the terminal
        std::cout << *it;
    }

    std::vector<codepoint_type> decoded;

    // Code point iterators work with STL algorithms
    // In this case we are copying the decoded code points into 
    // a vector of code points.
    std::copy(my_string.begin(), my_string.end(), std::back_inserter(decoded));
``

`unicode_string_adapter` does not provide direct way to access a string's code units in encoded form. This is 
because the whole purpose of this class is to hide the abstraction so that developer don't have to deal with 
strings of different encodings. Although code unit iterators can typically be obtained by calling the raw string's 
`begin()` method via `operator ->()`, it is strongly not recommended as doing so would make the code much less 
portable.

[endsect]

[endsect]


[section:unicode_string_adapter_builder Unicode String Adapter Builder]

Even though the nature of immutable string makes `unicode_string_adapter` much more efficient than most other mutable 
string types including std::string in C++11, certain mutable string operations are still unavoidable in some cases 
and there needs to be a way to construct mutable strings. Boost.Ustr solves the dilemma by introducing 
`unicode_string_adapter_builder` to complement the lack of mutability in `unicode_string_adapter`.

`unicode_string_adapter_builder` has the same template parameters as `unicode_string_adapter` and it also wraps a 
raw string type to perform the actual mutable string operations. However there is an important distiction of it from 
`unicode_string_adapter`: `unicode_string_adapter_builder` is a write only class, therefore it is not possible to 
read any code points or code units stored in it. To retrieve what have been stored in the adapter builder, developer 
must first call the `unicode_string_adapter_builder::freeze()` method which will freeze the string and return a 
`unicode_string_adapter` object, then only perform read operations on the immutable string adapter. This design 
forces Boost.Ustr users to choose from either read or write operation one at a time, leading to (what the author 
believes to be) a better design.

Other than the limitation to write-only operations, `unicode_string_adapter_builder` is also non-copyable. In C++11 
`unicode_string_adapter_builder` would behave similar to `std::unique_ptr` and is only movable through rvalue 
reference. At the moment there is no support for move constructor on compilers that do not support C++11, making 
the mutable adapter builder non-transferrable unless being freezed first.

``
    unicode_string_adapter_builder< std::string > my_buffer;

    // The append() method accepts a code point and encode 
    // it with targetted encoding and then store it in the 
    // raw string buffer.
    // The buffer now contains a single code point value of
    // the character '世'
    my_buffer.append(0x4E16);

    // The buffer appends the code point value of '界' 
    // and it now contains two code points forming the 
    // Unicode string "世界"
    my_buffer.append(0x754C);

    // A predefined Unicode string literal that contains the same word
    unicode_string_adapter< std::string > original_string = USTR("世界");

    // Does not compile: unicode_string_adapter_builder does not 
    // support operator ==() and other read operations
    // assert(my_buffer == original_string);

    unicode_string_adapter< std::string > frozen_string = my_buffer.freeze();

    // OK: Freezed string becomes immutable and the const string type 
    // allows read but not write operation
    assert(frozen_string == original_string);

    // Does not compile: unicode_string_adapter_builder is non-copyable
    // unicode_string_adapter_builder< std::string > buffer_copy = my_buffer;

    // OK in C++11: move semantics is supported based on platform availability
    unicode_string_adapter_builder< std::string > buffer_copy = std::move(my_buffer);

    // Only compilable in C++11. In C++03 the return value still requires
    // copy construction.
    unicode_string_adapter_builder< std::string > my_function() {
        ...
    }

    // Better do it this way: by passing the buffer as reference to functions
    void my_alternative_function(unicode_string_adapter_builder< std::string>& str) {
        ...
    }
``

[section:output_iterator Output Iterator]

The `begin()` method of `unicode_string_adapter_builder` returns a append-only output iterator. 
The iterator will append any code point values it receives through `operator =()` to the end of 
the underlying buffer. This is useful for building Unicode strings through STL algorithms. 
Notice however that the output iterator does not support `operator ==()`, which is a read operation.

``
    unicode_string_adapter_builder< std::string > my_buffer;

    typename unicode_string_adapter_builder< std::string >::iterator
    out = my_buffer.begin();

    // Same as my_buffer.append(0x4E16);
    *out++ = 0x4E16;
    *out++ = 0x754C;

    // Does not compile: output iterator does not support operator ==()
    // assert(*out == 0x754C);

    // Hypothetical function that retrieves code points from data source
    std::vector<codepoint_type> codepoints = get_codepoints_from_data_source();

    // We can append all the code points to the end of the buffer
    // using STL algorithms
    std::copy(codepoints.begin(), codepoints.end(), my_buffer.begin());
``

[endsect]

[section:append_codeunit Appending Code Units]

There are times where appending Unicode characters in encoded form is desirable, especially for cases like 
building Unicode strings from sources that contain already encoded strings such as through the network. 
To address such issue, there is a method `unicode_string_adapter_builder::append_codeunit` available to 
directly append encoded code units into the buffer. In this case the user is expected to make sure that the 
source encoding is the same as the buffer encoding, and also the encoding correctness of the source. If any 
malformed code unit is inserted into the buffer, the sequence will be detected and replaced according to the 
encoding policy of the string adapter.

There is also a code unit output iterator available by calling the 
`unicode_string_adapter_builder::codeunit_begin()` method. This may be useful to be used together with 
STL algorithms.

``
    // Char array with "世界" encoded in UTF-8
    const char encoded[] = { '\xE4', '\xB8', '\x96', '\xE7', '\x95', '\x8C' }

    unicode_string_adapter_builder< std::string > my_buffer;

    // Directly appended encoded code units. Developer must personally make sure 
    // that both encodings are the same.
    my_buffer.append_codeunit('\xE4');

    // Use STL algorithm to directly copy the encoded code units into the buffer
    // This must be done carefully or malformed string will be constructed
    std::copy(encoded+1, encoded+6, my_buffer.codeunit_begin());
``

[endsect]

[section:editing Editing Existing Unicode String Adapters]
To make modification on existing Unicode string adapters easy, there is an `unicode_string_adapter::edit()`
method available to create a mutable copy of string adapter having the same string content. Upon calling the
method, a new copy of the string content is made and stored in a `unicode_string_adapter_builder` object.
Modifications made to the mutable string adapter does not affect the original immutable string adapter, and
developer also has to call the `unicode_string_adapter_builder::method()` to read the modified string
content.

``
   unicode_string_adapter< std::string > my_string = USTR("世界");

   unicode_string_adapter_builder< std::string > mutable_copy = my_string.edit();
   mutable_copy.append(USTR("你好");

   unicode_string_adapter< std::string > freezed_copy = mutable_copy.freeze();

   assert(my_string == USTR("世界"));
   assert(my_string != USTR("世界你好"));
   assert(freezed_copy == USTR("世界你好"));
``
[endsect]

[endsect]

[section:advanced Advanced Techniques]
The `unicode_string_adapter` class has two optional template parameters that allow customization on the 
encoding algorithm and the behavior of the raw string.

[section:custom_string_traits Custom String Traits]
The `StringTraits` encoding traits defines common types for the raw string such as pointer types and also 
common operations such as raw string equality and append operation.

``
class StringTraits {
  public:
    typedef string_type;
    typedef codeunit_type;
    static const size_t codeunit_size;

    typedef raw_strptr_type;
    typedef const_raw_strptr_type;
    typedef const_strptr_type;
    typedef mutable_strptr_type;

    typedef codeunit_iterator_type;

    static raw_strptr_type new_string(const string_type& str);
    static raw_strptr_type new_string();
    static raw_strptr_type clone_string(raw_strptr_type str);

    struct string {
        static bool equals(const string_type& str1, const string_type& str2);

        template <typename Iterator>
        static string_type from_iter(Iterator begin, Iterator end);
    };

    struct raw_strptr {
        static bool equals(raw_strptr_type str1, raw_strptr_type str2);
        static bool equals(raw_strptr_type str1, const string_type& str2);
        static void delete_string(raw_strptr_type str);
    };

    struct const_strptr {
        static const_raw_strptr_type get(const const_strptr_type& str);
        static codeunit_iterator_type codeunit_begin(const const_strptr_type& str);
        static codeunit_iterator_type codeunit_end(const const_strptr_type& str);
        static bool equals(const_strptr_type str1, const_strptr_type str2);
    };

    struct mutable_strptr {
        static raw_strptr_type release(mutable_strptr_type& str);
        static raw_strptr_type get(mutable_strptr_type& str);
        static void append(mutable_strptr_type& str, codeunit_type codeunit);
    };
};
``

The `StringTraits::codeunit_type` is used to obtain the raw character type of the raw string while 
`StringTraits::codeunit_size` provides the size of the code units stored in the string. `codeunit_type` 
must behave the same as `char`, `char16_t`, or `char32_t` depending on the code unit size or undefined behavior 
will occur during the encoding/decoding process. For simplicity, there is currently no support for `CodeunitTraits` 
or `CharTraits`, so it is not possible to use existing `CharTraits` tricks similar in `std::basic_string` to further 
customize the string behavior.

Internally, `unicode_string_adapter` stores a smart pointer to the const raw string as the type 
`StringTraits::const_strptr_type`. By default this is either `std::shared_ptr<string_type>` in C++11 or 
`boost::shared_ptr<string_type>` otherwise. In custom string traits, developer may change the `const_strptr_type` 
to other smart pointer types or even be the same type as the raw string type if the raw string type offers 
copy-on-write operation.

`StringTraits::raw_strptr_type` is used to define the raw pointer to the raw string and is used during the construction 
and freezing of `unicode_string_adapter` instances.

`StringTraits::mutable_strptr_type` is treated as a `unique_ptr` holding a mutable instance of the raw string. If the 
underlying raw string type is fundamentally immutable, then `mutable_strptr_type` has to be redefined as a mutable buffer 
type that is later convertible to the immutable raw string when being frozen. Because no read operation will be performed 
on `mutable_strptr_type`, it is fine if the alternative buffer type has different read semantics as the immutable raw string type.

`StringTraits::codeunit_iterator_type` defines the const iterator type of the raw string when it's `begin()` and `end()` 
methods are called. The iterator must be readable but not writable and it is assumed that the iterator operations will not 
cause side effects to the raw string object.

`StringTraits` also defines four sub-traits that provide facade to string operations toward `string_type`, `raw_strptr_type`, 
`const_strptr_type` and `mutable_strptr_type`. Most of these functions are wrapper to common string operations including 
allocating new string on heap, deleting string, get the raw string pointer from the smart pointer, equality comparison 
between two strings, and calling `begin()` and `end()` methods of the string. 

Most of the requirements of `StringTraits` are pretty self explanatory in the default `detail/string_traits.hpp` source code. 

[endsect]

[section:custom_encoding_traits Custom Encoding Traits]
The `EncodingTraits` implements the actual encoding/decoding operation of different UTF encodings and works closely with 
`StringTraits` to perform the actual raw string-related operations. There are only two main interface that `EncodingTraits` 
provides, which will be explained below.

``
static void EncodingTraits::append_codepoint(
        typename StringTraits::mutable_strptr_type& str,
        const codepoint_type& codepoint);
``

This method takes a reference to a `mutable_strptr_type` and a const reference to codepoint and append the encoded code point 
to the end of the buffer. This is the core encoding operation that `EncodingTraits` provides.

``
class EncodingTraits::codepoint_iterator_type :
    public std::iterator<std::bidirectional_iterator_tag, codepoint_type>
{
  public:       
    codepoint_iterator_type(
        typename StringTraits::codeunit_iterator_type codeunit_it,
        typename StringTraits::codeunit_iterator_type begin,
        typename StringTraits::codeunit_iterator_type end);

    const codepoint_type operator *() const;
    ...
};
``

`EncodingTraits` provides a codepoint iterator that does decoding operations on the fly when being dereferenced through 
`operator *()`. The code point iterator class must fulfil the bidirectional iterator requirement and also the two interfaces 
specified above.

The constructor of the code point iterator takes three code unit iterators corresponding to the current position, beginning 
position, and end position respectively so that it can know the boundaries while transversing through the code units. The begin 
and end code unit iterators are both required as the code point iterator would increment or decrement in either directions, and 
it is important to avoid out of bound access of the underlying code unit iterator which can cause undefined behavior.

The `value_type` of the code point iterator is `codepoint_type`, and it should be treated like a virtual pointer to code points, 
not code units. The code point iterator hides the code unit abstraction layer so the user of the iterator should not require any 
knowledge on the underlying code units and encodings.

With custom `EncodingTraits`, it is possible to simulate Unicode behavior for strings that are not encoded in Unicode encodings. 
For example, one may implement custom encoding traits for the Shift-JIS japanese encoding to make the strings backward compatible 
with old applications while using these strings as if they are Unicode strings.

Another possibility for custom `EncodingTraits` is to implement URL escaped or HTML entities formatted encodings for ASCII-encoded 
strings. The custom encoding traits can then perform proper escape during encoding and decoding operations and thus allows developers 
to treat the Unicode-escaped ASCII-strings as if they are actual Unicode strings.

[endsect]

[section:replace_policy Replace Policy]
The `EncodingTraits` is also responsible to decide what to do when there is error during encoding/decoding operations. By default,
the default `encoding_traits` class provides an optional template parameter `Policy` that is used to decide the recovery action. 
The default policy class for this template parameter is `replace_policy<0xFFFD>`, which is a templated replacement policy class that 
replaces an invalid code point with the code point specified in the template parameter and 0xFFFD corresponds to the standard 
Unicode replacement character �.

There is also another class provided by Boost.Ustr which is the `error_policy`, which would throw an `encoding_error` exception 
when any of it's methods is called.

To implement a custom policy class, one simply has to implement two static methods within the class which are:

``
class Policy {
    static codepoint_type replace_invalid_codepoint();
    static codepoint_type replace_invalid_codepoint(codepoint_type original);
};
``

The zero-argument version of `replace_invalid_codepoint()` is used during decoding error while the one-argument version is used 
during encoding of a code point with invalid value.

It is recommended that custom encoding traits also accept the policy class in their template parameters to allow users to customize 
the error behavior according to their needs.

[endsect]

[endsect]

[section:examples Examples]
[endsect]

[xinclude autodoc.xml]
